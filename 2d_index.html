<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>AlphaZero Tic‑Tac‑Toe — MCTS Explainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <style>
    :root { 
      --bg:#ffffff; 
      --panel:#f6f8fa; 
      --text:#24292f; 
      --muted:#6e7781; 
      --accent:#0969da; 
      --border:#d0d7de; 
      --grid:#d8dee4;
    }
    * { box-sizing: border-box; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    body { margin:0; background:var(--bg); color:var(--text); -webkit-font-smoothing:antialiased; }
    header { padding:16px 20px; border-bottom:1px solid var(--border); display:flex; align-items:center; gap:12px; background:#ffffffcc; backdrop-filter:saturate(180%) blur(8px); }
    header h1 { margin:0; font-size:18px; font-weight:600; }
    main { display:grid; grid-template-columns: 420px 1fr; gap:16px; padding:16px; align-items:start; }
    .card { background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:12px; box-shadow:0 1px 2px rgba(0,0,0,0.04); }
    #board-wrap { display:flex; flex-direction:column; gap:10px; }
    #board { display:block; width:100%; max-width:390px; aspect-ratio:1/1; background:#fff; border-radius:8px; border:1px solid var(--border); }
    .controls { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .row { display:grid; grid-template-columns: 140px 1fr auto; gap:8px; align-items:center; }
    input[type=range] { width:100%; }
    button { background:#f6f8fa; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:8px 10px; cursor:pointer; transition:background .15s, box-shadow .15s; }
    button:hover { background:#eef2f7; }
    button:active { background:#e2e8ef; }
    table { width:100%; border-collapse:collapse; font-size:14px; }
    th, td { padding:6px 8px; border-bottom:1px solid var(--border); text-align:right; }
    th { background:#f0f3f6; font-weight:600; }
    th:first-child, td:first-child { text-align:left; }
    .pill { font-size:12px; background:rgba(9,105,218,0.08); color:var(--accent); border:1px solid rgba(9,105,218,0.3); padding:2px 6px; border-radius:999px; }
    .legend { display:flex; gap:8px; align-items:center; margin-top:6px; color:var(--muted); font-size:12px; }
    .muted { color:var(--muted); }
    .grid { display:grid; grid-template-columns: repeat(3, 1fr); gap:6px; }
    .bar { height:8px; background:#eaeef2; border:1px solid var(--border); border-radius:999px; overflow:hidden; }
    .bar > div { height:100%; background:var(--accent); }
    .row-inline { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    @media (max-width: 900px){
      main { grid-template-columns: 1fr; }
      #board-wrap { order:2; }
      main > section:first-child { position:relative; }
    }
  </style>
</head>
<body>
  <header>
    <h1>AlphaZero Tic‑Tac‑Toe — MCTS Explainer</h1>
    <span class="pill">ONNX in browser</span>
  </header>

  <main>
    <section class="card" id="board-wrap">
      <canvas id="board" width="390" height="390"></canvas>
      <div class="controls">
        <div class="row">
          <label>Simulations</label>
          <input id="sims" type="range" min="10" max="1000" value="200"/>
          <span class="mono" id="simsVal">200</span>
        </div>
        <div class="row">
          <label>c_puct</label>
          <input id="cpuct" type="range" min="0.2" max="3.0" step="0.05" value="1.0"/>
          <span class="mono" id="cpuctVal">1.00</span>
        </div>
        <div class="row">
          <label>Temperature τ</label>
          <input id="temp" type="range" min="0" max="1" step="0.05" value="0.1"/>
          <span class="mono" id="tempVal">0.10</span>
        </div>
        <div class="row">
          <label>Dirichlet ε</label>
          <input id="eps" type="range" min="0" max="0.5" step="0.05" value="0.25"/>
          <span class="mono" id="epsVal">0.25</span>
        </div>
        <div class="row">
          <label>Dirichlet α</label>
          <input id="alpha" type="range" min="0.05" max="1.0" step="0.05" value="0.3"/>
          <span class="mono" id="alphaVal">0.30</span>
        </div>
        <div class="row-inline">
          <button id="run">Run MCTS</button>
          <button id="aiMove">AI Move</button>
          <button id="reset">Reset</button>
        </div>
      </div>
      <div class="legend">
        <div style="width:14px;height:14px;background:var(--accent);opacity:0.15;border:1px solid #30363d;"></div>
        <span>Heat = visit probability π</span>
      </div>
    </section>

    <section class="card">
      <h3 style="margin:6px 0 10px 0;">Root analysis</h3>
      <div class="grid" id="piBars"></div>
      <div class="muted" style="margin:8px 0;">Per‑move statistics (legal actions only)</div>
      <table>
        <thead><tr><th>Cell</th><th>N</th><th>Q(parent)</th><th>P</th><th>U</th><th>π</th></tr></thead>
        <tbody id="statsBody"></tbody>
      </table>
      <div style="margin-top:10px;">
        <span>Predicted value v(s): <span class="mono" id="predV">—</span></span>
      </div>
    </section>
  </main>

<script>
/* ===== Utilities ===== */
const softmax = (arr) => {
  const max = Math.max(...arr);
  const exps = arr.map(v => Math.exp(v - max));
  const s = exps.reduce((a,b)=>a+b,0);
  return exps.map(v=>v/s);
};
const normalize = (xs) => {
  const s = xs.reduce((a,b)=>a+b,0);
  return s > 0 ? xs.map(v=>v/s) : xs.map(_=>0);
};

/* ===== Game ===== */
class Game {
  constructor(board=null, player=1) {
    this.board = board ? Int8Array.from(board) : new Int8Array(9).fill(0);
    this.player = player; // 1 or -1
  }
  clone(){ return new Game(this.board, this.player); }
  validMoves(){ const a=[]; for(let i=0;i<9;i++) if(this.board[i]===0) a.push(i); return a; }
  makeMove(a){
    if(this.board[a]!==0) return false;
    this.board[a]=this.player;
    this.player = -this.player;
    return true;
  }
  score(){
    const b=this.board;
    const lines=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
    for(const [i,j,k] of lines){
      if(b[i]!==0 && b[i]===b[j] && b[j]===b[k]) return b[i];
    }
    return 0;
  }
  over(){ return this.score()!==0 || this.validMoves().length===0; }
}

/* ===== ONNX Model wrapper ===== */
class ONNXAlphaZero {
  async load(url="model.onnx"){
    this.session = await ort.InferenceSession.create(url, { executionProviders: ['wasm'] });
  }
  encode(game){
    // planes: current player stones, opponent stones; shape [1,3,3,2]
    const cur = game.player;
    const planes = new Float32Array(1*3*3*2);
    for(let i=0;i<9;i++){
      const r=Math.floor(i/3), c=i%3;
      const base = (r*3 + c)*2;
      planes[base+0] = (game.board[i]===cur) ? 1.0 : 0.0;
      planes[base+1] = (game.board[i]===-cur) ? 1.0 : 0.0;
    }
    return planes;
  }
  async predict(game){
    const input = this.encode(game);
    const feeds = { "input": new ort.Tensor('float32', input, [1,3,3,2]) };
    const out = await this.session.run(feeds);
    const v = out["value"].data[0];
    const logits = Array.from(out["policy_logits"].data);
    return { v, logits };
  }
}

/* ===== MCTS ===== */
class Node {
  constructor(state, parent=null, action=null, prior=0){
    this.state = state; // {board:Int8Array, player:int}
    this.parent = parent;
    this.action = action;
    this.prior = prior;
    this.children = new Map(); // action -> Node
    this.N = 0;
    this.W = 0; // sum of values from this node's perspective
  }
  get Q(){ return this.N ? this.W / this.N : 0; }
  QFromParent(){ return -this.Q; }
}

class MCTS {
  constructor(game, model, c_puct=1.0, alpha=0.3, eps=0.25){
    this.game = game;
    this.model = model;
    this.c_puct = c_puct;
    this.alpha = alpha;
    this.eps = eps;
  }

  async search(simulations=200){
    const root = new Node({board:this.game.board.slice(), player:this.game.player});
    await this.expandWithNoise(root); // no backup here

    for(let s=0; s<simulations; s++){
      let node = root;
      const g = new Game(root.state.board, root.state.player);

      // Selection
      while(node.children.size>0 && !g.over()){
        node = this.select(node);
        g.makeMove(node.action);
      }

      // Expansion or terminal backup
      if(!g.over()){
        const v = await this.expand(node, g);
        this.backup(node, v);
      } else {
        const terminalV = g.score() * g.player; // player-to-move view at terminal
        this.backup(node, terminalV);
      }
    }
    return root;
  }

  select(node){
    const parentVisits = 1 + node.N;
    let best=null, bestScore=-Infinity;
    for(const child of node.children.values()){
      const U = this.c_puct * child.prior * (Math.sqrt(parentVisits) / (1 + child.N));
      const score = child.QFromParent() + U;
      if(score > bestScore){ bestScore=score; best=child; }
    }
    return best;
  }

  async expand(node, game){
    const { v, logits } = await this.model.predict(game);
    const legal = game.validMoves();
    const masked = legal.map(a => logits[a]);
    const probsL = softmax(masked);
    // normalize back to action ids
    for(let i=0;i<legal.length;i++){
      const a = legal[i];
      if(!node.children.has(a)){
        const childState = {board:game.board.slice(), player:game.player};
        const child = new Node(childState, node, a, probsL[i]);
        node.children.set(a, child);
      }
    }
    return v; // from player-to-move perspective
  }

  async expandWithNoise(root){
    const g = new Game(root.state.board, root.state.player);
    if(g.over()) return;

    const { v, logits } = await this.model.predict(g);
    const legal = g.validMoves();
    if(legal.length===0) return;

    const priors = softmax(legal.map(a => logits[a]));
    // Dirichlet noise
    const noise = this.dirichlet(this.alpha, legal.length);
    const mixed = priors.map((p,i)=> (1-this.eps)*p + this.eps*noise[i]);

    for(let i=0;i<legal.length;i++){
      const a = legal[i];
      const childState = {board:g.board.slice(), player:g.player};
      const child = new Node(childState, root, a, mixed[i]);
      root.children.set(a, child);
    }
    // do NOT backup here
  }

  backup(node, vLeaf){
    // vLeaf is from leaf's player-to-move view; alternate signs on the way up
    let cur = node;
    let v = vLeaf;
    while(cur){
      cur.N += 1;
      cur.W += v;
      v = -v;
      cur = cur.parent;
    }
  }

  dirichlet(alpha, k){
    // Gamma sampling via Marsaglia-Tsang for alpha>0
    const samples = new Array(k).fill(0).map(()=>this.gamma(alpha,1));
    const sum = samples.reduce((a,b)=>a+b,0);
    return samples.map(x=>x/sum);
  }
  gamma(shape, scale){
    // Simple Gamma(shape, scale). shape>0
    if(shape < 1){
      const u = Math.random();
      return this.gamma(1+shape, scale)*Math.pow(u, 1/shape);
    }
    const d = shape - 1/3;
    const c = 1/Math.sqrt(9*d);
    while(true){
      let x, v;
      do {
        x = this.normal();
        v = 1 + c*x;
      } while (v <= 0);
      v = v*v*v;
      const u = Math.random();
      if (u < 1 - 0.0331*(x*x)*(x*x)) return scale*d*v;
      if (Math.log(u) < 0.5*x*x + d*(1 - v + Math.log(v))) return scale*d*v;
    }
  }
  normal(){
    // Box-Muller
    const u = 1 - Math.random();
    const v = 1 - Math.random();
    return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
  }
}

/* ===== UI + Orchestration ===== */
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
const SIZE = 390, CELL = SIZE/3; // internal logical size (canvas will scale with CSS)
const simsInput = document.getElementById("sims");
const cpuctInput = document.getElementById("cpuct");
const tempInput = document.getElementById("temp");
const epsInput = document.getElementById("eps");
const alphaInput = document.getElementById("alpha");
const simsVal = document.getElementById("simsVal");
const cpuctVal = document.getElementById("cpuctVal");
const tempVal = document.getElementById("tempVal");
const epsVal = document.getElementById("epsVal");
const alphaVal = document.getElementById("alphaVal");
const statsBody = document.getElementById("statsBody");
const piBars = document.getElementById("piBars");
const predV = document.getElementById("predV");

let game = new Game();
let model = new ONNXAlphaZero();
let lastRoot = null;

function draw(board, visitsPi=null){
  // background
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,SIZE,SIZE);
  // grid
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || '#d8dee4';
  ctx.lineWidth = 2;
  for(let i=1;i<3;i++){
    ctx.beginPath(); ctx.moveTo(i*CELL,0); ctx.lineTo(i*CELL,SIZE); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,i*CELL); ctx.lineTo(SIZE,i*CELL); ctx.stroke();
  }
  // heat
  if(visitsPi){
    for(let i=0;i<9;i++){
      if(visitsPi[i]>0){
        const r = Math.floor(i/3), c=i%3;
  ctx.fillStyle = `rgba(9,105,218,${0.10 + 0.35*visitsPi[i]})`;
        ctx.fillRect(c*CELL+3, r*CELL+3, CELL-6, CELL-6);
      }
    }
  }
  // pieces
  for(let i=0;i<9;i++){
    const r=Math.floor(i/3), c=i%3, x=c*CELL, y=r*CELL;
    if(board[i]===1){ // X
  ctx.strokeStyle="#1f2328"; ctx.lineWidth=6;
      ctx.beginPath(); ctx.moveTo(x+20,y+20); ctx.lineTo(x+CELL-20,y+CELL-20); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+CELL-20,y+20); ctx.lineTo(x+20,y+CELL-20); ctx.stroke();
    } else if(board[i]===-1){ // O
  ctx.strokeStyle="#1f2328"; ctx.lineWidth=6;
      ctx.beginPath(); ctx.arc(x+CELL/2,y+CELL/2, CELL/2-24, 0, Math.PI*2); ctx.stroke();
    }
  }
}

function toPiFromVisits(root, tau){
  const counts = new Array(9).fill(0);
  let sumN = 0;
  for(const [a, child] of root.children.entries()){
    counts[a] = child.N;
    sumN += child.N;
  }
  if(sumN===0) return normalize(counts);
  if(tau===0){
    const idx = counts.indexOf(Math.max(...counts));
    const pi = new Array(9).fill(0); pi[idx]=1; return pi;
  } else {
    const pow = counts.map(n => Math.pow(n, 1.0/Math.max(tau,1e-6)));
    const s = pow.reduce((a,b)=>a+b,0);
    return s>0 ? pow.map(v=>v/s) : normalize(counts);
  }
}

function updateStats(root, tau){
  // Compute π, and per-move stats
  const pi = toPiFromVisits(root, tau);
  draw(game.board, pi);

  // π bars 3x3
  piBars.innerHTML = "";
  for(let i=0;i<9;i++){
    const wrap = document.createElement("div");
    wrap.innerHTML = `<div class="bar"><div style="width:${(pi[i]*100).toFixed(1)}%"></div></div>
      <div class="muted" style="font-size:12px;margin-top:2px;">Cell ${i} • ${(pi[i]*100).toFixed(1)}%</div>`;
    piBars.appendChild(wrap);
  }

  // stats rows
  const parentN = 1 + root.N;
  const rows = [];
  for(const [a, child] of root.children.entries()){
    const U = child.prior * (Math.sqrt(parentN) / (1 + child.N)) * parseFloat(cpuctInput.value);
    const row = `
      <tr>
        <td>${a}</td>
        <td>${child.N}</td>
        <td>${child.QFromParent().toFixed(3)}</td>
        <td>${child.prior.toFixed(3)}</td>
        <td>${U.toFixed(3)}</td>
        <td>${(pi[a]*100).toFixed(1)}%</td>
      </tr>`;
    rows.push([child.N, row]);
  }
  rows.sort((x,y)=>y[0]-x[0]);
  statsBody.innerHTML = rows.map(x=>x[1]).join("");

  predV.textContent = root.children.size ? avgRootQ(root).toFixed(3) : "—";
}

function avgRootQ(root){
  // estimate root value as visit-weighted mean of child Q(parent)
  let num=0, den=0;
  for(const child of root.children.values()){
    num += child.N * child.QFromParent();
    den += child.N;
  }
  return den>0 ? num/den : 0;
}

// UI wiring
canvas.addEventListener("click", async (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  const c = Math.floor(x / CELL), r = Math.floor(y / CELL);
  const idx = r*3 + c;
  if(game.board[idx]!==0 || game.over()) return;
  game.makeMove(idx);
  draw(game.board, null);
  lastRoot = null;
});

document.getElementById("reset").addEventListener("click", ()=>{
  game = new Game();
  lastRoot = null;
  draw(game.board, null);
});

document.getElementById("run").addEventListener("click", async ()=>{
  await runMCTSOnce();
});

document.getElementById("aiMove").addEventListener("click", async ()=>{
  await runMCTSOnce();
  const pi = toPiFromVisits(lastRoot, parseFloat(tempInput.value));
  const legal = game.validMoves();
  if(legal.length===0) return;
  // pick argmax π
  let best=legal[0], bestP=-1;
  for(const a of legal){ if(pi[a] > bestP){ bestP=pi[a]; best=a; } }
  game.makeMove(best);
  lastRoot = null;
  draw(game.board, null);
});

for(const [elt, out] of [[simsInput,simsVal],[cpuctInput,cpuctVal],[tempInput,tempVal],[epsInput,epsVal],[alphaInput,alphaVal]]){
  elt.addEventListener("input", ()=>{ out.textContent = parseFloat(elt.value).toFixed(elt===cpuctInput?2:2); });
  out.textContent = parseFloat(elt.value).toFixed(elt===cpuctInput?2:2);
}

async function runMCTSOnce(){
  const sims = parseInt(simsInput.value);
  const cpuct = parseFloat(cpuctInput.value);
  const eps = parseFloat(epsInput.value);
  const alpha = parseFloat(alphaInput.value);
  const tau = parseFloat(tempInput.value);

  const mcts = new MCTS(game.clone(), model, cpuct, alpha, eps);
  lastRoot = await mcts.search(sims);
  updateStats(lastRoot, tau);
}

(async function boot(){
  draw(game.board, null);
  await model.load("model.onnx");
  await runMCTSOnce();
})();
</script>
</body>
</html>